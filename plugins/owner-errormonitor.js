
import fs from 'fs'

const handler = async (m, { conn, args, usedPrefix, command }) => {
  const action = args[0]?.toLowerCase()
  
  if (!action) {
    return conn.reply(m.chat, `üö® *MONITOR DE ERRORES* üö®

üìã **Opciones disponibles:**
‚Ä¢ ${usedPrefix + command} status - Estado del monitor
‚Ä¢ ${usedPrefix + command} start - Iniciar monitoreo
‚Ä¢ ${usedPrefix + command} stop - Detener monitoreo
‚Ä¢ ${usedPrefix + command} clear - Limpiar logs
‚Ä¢ ${usedPrefix + command} recent - Ver errores recientes
‚Ä¢ ${usedPrefix + command} subbots - Errores de sub-bots

*Ejemplo:* ${usedPrefix + command} start`, m)
  }

  await m.react('üîç')

  try {
    switch (action) {
      case 'status':
        await showMonitorStatus(conn, m)
        break
      case 'start':
        await startErrorMonitoring(conn, m)
        break
      case 'stop':
        await stopErrorMonitoring(conn, m)
        break
      case 'clear':
        await clearErrorLogs(conn, m)
        break
      case 'recent':
        await showRecentErrors(conn, m)
        break
      case 'subbots':
        await showSubBotErrors(conn, m)
        break
      default:
        return conn.reply(m.chat, '‚ùå Acci√≥n no v√°lida.', m)
    }

    await m.react('‚úÖ')
  } catch (e) {
    console.error(e)
    await m.react('‚ùå')
    conn.reply(m.chat, `‚ùå Error en monitor: ${e.message}`, m)
  }
}

// Mostrar estado del monitor
async function showMonitorStatus(conn, m) {
  let response = `üö® *ESTADO DEL MONITOR* üö®\n\n`
  
  response += `üìä **Monitor Principal:**\n`
  response += `‚Ä¢ Estado: ${global.errorMonitor?.active ? 'üü¢ Activo' : 'üî¥ Inactivo'}\n`
  response += `‚Ä¢ Errores capturados: ${global.errorLog?.length || 0}\n`
  response += `‚Ä¢ √öltimo error: ${global.errorLog?.length > 0 ? 
    new Date(global.errorLog[global.errorLog.length - 1].timestamp).toLocaleString('es-ES') : 
    'N/A'}\n\n`

  response += `üë• **Sub-Bots:**\n`
  if (global.subBotErrors) {
    const totalSubBotErrors = Object.values(global.subBotErrors).reduce((sum, errors) => sum + errors.length, 0)
    response += `‚Ä¢ Errores totales: ${totalSubBotErrors}\n`
    response += `‚Ä¢ Sub-bots con errores: ${Object.keys(global.subBotErrors).length}\n`
  } else {
    response += `‚Ä¢ Sin errores registrados\n`
  }

  response += `\n‚öôÔ∏è **Configuraci√≥n:**\n`
  response += `‚Ä¢ Max errores guardados: 100\n`
  response += `‚Ä¢ Auto-notificaci√≥n: ${global.errorMonitor?.autoNotify ? '‚úÖ' : '‚ùå'}\n`
  response += `‚Ä¢ Log a archivo: ${global.errorMonitor?.logToFile ? '‚úÖ' : '‚ùå'}\n`

  await conn.reply(m.chat, response, m)
}

// Iniciar monitoreo de errores
async function startErrorMonitoring(conn, m) {
  if (global.errorMonitor?.active) {
    return conn.reply(m.chat, '‚ö†Ô∏è El monitor ya est√° activo.', m)
  }

  // Inicializar sistema de monitoreo
  global.errorMonitor = {
    active: true,
    autoNotify: true,
    logToFile: true,
    startTime: Date.now(),
    notificationsSent: 0
  }

  if (!global.errorLog) global.errorLog = []
  if (!global.subBotErrors) global.subBotErrors = {}

  // Interceptar errores de proceso
  if (!global.errorMonitor.processErrorHandler) {
    global.errorMonitor.processErrorHandler = (error) => {
      logError('PROCESS', error.message, error.stack)
    }
    process.on('uncaughtException', global.errorMonitor.processErrorHandler)
    process.on('unhandledRejection', global.errorMonitor.processErrorHandler)
  }

  // Interceptar errores de consola
  if (!global.originalConsoleError) {
    global.originalConsoleError = console.error
    console.error = (...args) => {
      const message = args.join(' ')
      logError('CONSOLE', message)
      global.originalConsoleError(...args)
    }
  }

  let response = `üö® *MONITOR INICIADO* üö®\n\n`
  response += `‚úÖ Monitor de errores activado\n`
  response += `üìä Interceptando errores de:\n`
  response += `‚Ä¢ Procesos no capturados\n`
  response += `‚Ä¢ Promesas rechazadas\n`
  response += `‚Ä¢ Errores de consola\n`
  response += `‚Ä¢ Sub-bots conectados\n\n`
  response += `üîî Se notificar√°n errores cr√≠ticos autom√°ticamente`

  await conn.reply(m.chat, response, m)
}

// Detener monitoreo
async function stopErrorMonitoring(conn, m) {
  if (!global.errorMonitor?.active) {
    return conn.reply(m.chat, '‚ö†Ô∏è El monitor no est√° activo.', m)
  }

  global.errorMonitor.active = false

  // Restaurar console.error original
  if (global.originalConsoleError) {
    console.error = global.originalConsoleError
    delete global.originalConsoleError
  }

  // Remover listeners de proceso
  if (global.errorMonitor.processErrorHandler) {
    process.removeListener('uncaughtException', global.errorMonitor.processErrorHandler)
    process.removeListener('unhandledRejection', global.errorMonitor.processErrorHandler)
    delete global.errorMonitor.processErrorHandler
  }

  const uptime = Math.floor((Date.now() - global.errorMonitor.startTime) / 1000)
  
  let response = `üö® *MONITOR DETENIDO* üö®\n\n`
  response += `‚èπÔ∏è Monitor desactivado\n`
  response += `‚è±Ô∏è Tiempo activo: ${uptime}s\n`
  response += `üìä Errores capturados: ${global.errorLog?.length || 0}\n`
  response += `üîî Notificaciones enviadas: ${global.errorMonitor.notificationsSent}\n\n`
  response += `üíæ Los logs se mantienen hasta limpiar manualmente`

  await conn.reply(m.chat, response, m)
}

// Limpiar logs de errores
async function clearErrorLogs(conn, m) {
  const totalErrors = (global.errorLog?.length || 0) + 
    Object.values(global.subBotErrors || {}).reduce((sum, errors) => sum + errors.length, 0)

  global.errorLog = []
  global.subBotErrors = {}

  let response = `üßπ *LOGS LIMPIADOS* üßπ\n\n`
  response += `‚úÖ Eliminados ${totalErrors} errores\n`
  response += `üìä Estado: Limpio\n`
  response += `üîÑ Monitor: ${global.errorMonitor?.active ? 'Activo' : 'Inactivo'}`

  await conn.reply(m.chat, response, m)
}

// Mostrar errores recientes
async function showRecentErrors(conn, m) {
  if (!global.errorLog || global.errorLog.length === 0) {
    return conn.reply(m.chat, '‚úÖ No hay errores recientes registrados.', m)
  }

  let response = `üìã *ERRORES RECIENTES* üìã\n\n`
  
  const recentErrors = global.errorLog.slice(-10).reverse()
  
  recentErrors.forEach((error, index) => {
    const time = new Date(error.timestamp).toLocaleString('es-ES', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    })
    
    response += `${index + 1}. [${time}] ${error.type || 'ERROR'}\n`
    response += `   ${error.message.substring(0, 80)}${error.message.length > 80 ? '...' : ''}\n\n`
  })

  response += `üìä Total errores: ${global.errorLog.length}\n`
  response += `‚è∞ √öltimo: ${new Date(global.errorLog[global.errorLog.length - 1].timestamp).toLocaleString('es-ES')}`

  await conn.reply(m.chat, response, m)
}

// Mostrar errores de sub-bots
async function showSubBotErrors(conn, m) {
  if (!global.subBotErrors || Object.keys(global.subBotErrors).length === 0) {
    return conn.reply(m.chat, '‚úÖ No hay errores de sub-bots registrados.', m)
  }

  let response = `üë• *ERRORES DE SUB-BOTS* üë•\n\n`

  for (const [botNumber, errors] of Object.entries(global.subBotErrors)) {
    if (errors.length === 0) continue

    const isVip = global.premiumSubBots?.includes(botNumber)
    response += `${isVip ? 'üíé' : 'üÜì'} **+${botNumber}** (${errors.length} errores)\n`
    
    // Mostrar √∫ltimos 3 errores de este sub-bot
    const recentErrors = errors.slice(-3).reverse()
    recentErrors.forEach((error, index) => {
      const time = new Date(error.timestamp).toLocaleString('es-ES', {
        hour: '2-digit',
        minute: '2-digit'
      })
      response += `   ${index + 1}. [${time}] ${error.message.substring(0, 50)}...\n`
    })
    response += `\n`
  }

  const totalSubBotErrors = Object.values(global.subBotErrors).reduce((sum, errors) => sum + errors.length, 0)
  response += `üìä **Resumen:**\n`
  response += `‚Ä¢ Total errores: ${totalSubBotErrors}\n`
  response += `‚Ä¢ Sub-bots afectados: ${Object.keys(global.subBotErrors).length}\n`

  await conn.reply(m.chat, response, m)
}

// Funci√≥n para registrar errores
function logError(type, message, stack = null) {
  if (!global.errorLog) global.errorLog = []

  const errorEntry = {
    timestamp: new Date().toISOString(),
    type: type,
    message: message,
    stack: stack
  }

  global.errorLog.push(errorEntry)

  // Mantener solo los √∫ltimos 100 errores
  if (global.errorLog.length > 100) {
    global.errorLog = global.errorLog.slice(-100)
  }

  // Auto-notificar errores cr√≠ticos
  if (global.errorMonitor?.autoNotify && shouldNotifyError(message)) {
    notifyCriticalError(errorEntry)
  }

  // Log a archivo si est√° habilitado
  if (global.errorMonitor?.logToFile) {
    try {
      const logLine = `[${errorEntry.timestamp}] ${type}: ${message}\n`
      fs.appendFileSync('./tmp/error.log', logLine)
    } catch (e) {
      // Silently fail if can't write to file
    }
  }
}

// Verificar si un error debe notificarse
function shouldNotifyError(message) {
  const criticalKeywords = [
    'ENOTFOUND',
    'ECONNRESET',
    'TypeError',
    'ReferenceError',
    'SyntaxError',
    'Maximum call stack',
    'out of memory'
  ]

  return criticalKeywords.some(keyword => 
    message.toLowerCase().includes(keyword.toLowerCase())
  )
}

// Notificar error cr√≠tico al owner
async function notifyCriticalError(error) {
  try {
    if (global.errorMonitor.notificationsSent >= 10) {
      return // Evitar spam de notificaciones
    }

    const message = `üö® *ERROR CR√çTICO DETECTADO* üö®\n\n` +
      `‚è∞ **Tiempo:** ${new Date(error.timestamp).toLocaleString('es-ES')}\n` +
      `üî¥ **Tipo:** ${error.type}\n` +
      `üí¨ **Mensaje:** ${error.message}\n\n` +
      `> Sistema de monitoreo autom√°tico`

    for (const [ownerNumber] of global.owner) {
      const ownerJid = ownerNumber + '@s.whatsapp.net'
      await global.conn.sendMessage(ownerJid, { text: message })
    }

    global.errorMonitor.notificationsSent++
  } catch (e) {
    console.log('Error enviando notificaci√≥n cr√≠tica:', e)
  }
}

// Funci√≥n global para registrar errores de sub-bots
global.logSubBotError = function(botNumber, message) {
  if (!global.subBotErrors) global.subBotErrors = {}
  if (!global.subBotErrors[botNumber]) global.subBotErrors[botNumber] = []

  global.subBotErrors[botNumber].push({
    timestamp: new Date().toISOString(),
    message: message
  })

  // Mantener solo los √∫ltimos 20 errores por sub-bot
  if (global.subBotErrors[botNumber].length > 20) {
    global.subBotErrors[botNumber] = global.subBotErrors[botNumber].slice(-20)
  }
}

handler.help = ['errormonitor', 'monitorerrores']
handler.tags = ['owner']
handler.command = /^(errormonitor|monitorerrores|monitor)$/i
handler.owner = true

export default handler
